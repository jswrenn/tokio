use crate::runtime::{self, taskdump};
use std::{
    fs::{File, OpenOptions},
    io::Write,
    path::PathBuf,
};

/// Tests that generated taskdumps match their schema.
///
/// Failures of these tasks suggest a buggy implementation of `JsonSchema`.
mod model_test {
    use super::*;

    /// Tests that a taskdump generated by the current-thread runtime
    /// satisfies the JSON schema associated with the taskdump.
    #[test]
    fn current_thread() {
        let runtime = runtime::Builder::new_current_thread().build().unwrap();
        test_runtime(runtime.handle());
    }

    cfg_taskdump! {
        /// Tests that a taskdump generated by the multi-thread runtime
        /// satisfies the JSON schema associated with the taskdump.
        #[test]
        fn multi_thread() {
            let runtime = runtime::Builder::new_multi_thread()
                .build()
                .unwrap();
            test_runtime(runtime.handle());
        }
    }

    fn test_runtime(handle: &crate::runtime::Handle) {
        let taskdump = taskdump::Runtime::from(handle);
        let taskdump = serde_json::to_value(taskdump).unwrap();

        let schema = {
            let value = schema_from_file();
            jsonschema::JSONSchema::compile(&value).unwrap()
        };

        let result = schema.validate(&taskdump);

        if let Err(errors) = result {
            let errors: Vec<_> = errors.map(|e| format!("{}", e)).collect();
            let errors = errors.join("\n");
            panic!("Validation Errors:\n{}", errors);
        }
    }
}

/// Checks that `taskdump_schema.json` is up-to-date.
///
/// See [`UI_FAILURE_MESSAGE`] for guidance on how to regenerate this file.
#[test]
fn schema() {
    // the schema generated from code.
    let actual = {
        let schema = schemars::schema_for!(crate::runtime::taskdump::Runtime);
        serde_json::to_value(&schema).unwrap()
    };

    if should_bless() {
        writeln!(schema_file(), "{:#}", actual).unwrap();
        return;
    }

    // the schema from disk.
    let expected = schema_from_file();

    assert_eq!(expected, actual, "{}", UI_FAILURE_MESSAGE);
}

/// Produces `true` if `--bless` is provided as a CLI argument during testing,
/// otherwise false.
fn should_bless() -> bool {
    std::env::args().find(|arg| arg == "--bless").is_some()
}

const UI_FAILURE_MESSAGE: &str = r"The schema on disk (left) did not match the \
    schema generated from code (right). To overwrite the schema on disk, run:
$ RUSTFLAGS='--cfg tokio_unstable' cargo test --features taskdump,full \
    --lib -- runtime::tests::taskdump::schema -- --bless
";

/// A deserialization of the contents of `taskdump_schema.json` at compile time.
fn schema_from_file() -> serde_json::Value {
    static SCHEMA_TEXT: &str = include_str!("taskdump_schema.json");
    serde_json::from_str(SCHEMA_TEXT).unwrap()
}

/// A handle to the file `taskdump_schema.json`, whose contents are writable.
fn schema_file() -> File {
    let schema_path = {
        let mut buf = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        assert!(buf.pop());
        buf.push(file!());
        assert!(buf.pop());
        buf.push("taskdump_schema.json");
        buf
    };

    OpenOptions::new()
        .read(false)
        .write(true)
        .create(false)
        .open(schema_path)
        .unwrap()
}
